I'll explain all the programs as well as the modifications made in them one by one below:

Complex.cpp:
I overloaded the operators for subtraction, multiplication and division in this program. The implementation of division kept the goals of this lab in mind, and used only multiplication. In fact, in the same expression, * was used in two different contexts, as a pointer (*this) and as symbol of multiplication, all the while also demonstrating cascading! It's interesting to see how the compiler is able to distiguish between these two. The programs written by sir demonstrate that assignment follows right to left parsing, while addition follows left to right parsing. The order of parsing becomes especially important in cases where cascading takes place with an operator which is non-commutative, such as subtraction, which is shown below.

Collection.cpp:
This is a very interesting program in the sense that the operator "<<" has not only been overloaded (once by sir, once by me to implement the bulk insertion operator), but has been OVERLOADED TWICE FOR TWO DIFFERENT SIGNATURES.(Sir's << takes integers as arguments, mine takes the object "collection" itself). In addition, accessor and mutator functions have been defined for extracting various information from the "external" object while overloading binary operators. This, however, doesn't violate the OOP as those functions have been kept private, ie:- they can be accessed only within th object, thus preventing misuse. The << and >> keep in mind the LIFO structure of the stack amd hence have been accordingly defined and implemented.


why-it-fails.cpp:
Note that the operators "<<" and "||" are both read left to right. Thus, the sequence of expressions (keep in mind that the precedence order is || < >>) is cout << a, a || b, b << endl. However, note that << hasn't been overloaded to accomodate arguments like b, which is of type bool, and hence gives the error: invalid operands of types ‘bool’ and ‘<unresolved overloaded function type>’ to binary ‘operator<<’, as expected. The clear way to rectify it is put a bracket around a || b. Then, the sequence of operations is a || b (stored in a temporary, named say 'arg'), cout << arg, and then the buffer is flushed using endl, which is a perfectly legitimate sequnce of operations to carry out.

lval-rval.cpp:
First let me explain the line of code that works, ie:- ++x = x++; Note that the precedence order is postfix increment > prefix increment > assignment. Thus,first x++ is carried out. What does that give us: A variable temp (inside the compiler) storing the original value of x (=10), while the value of x increases to 11. Then ++x is carried out, which creates another temporary variable (say temp2) storing 11 + 1 = 12 inside itself, while the value of x increases from 11 to 12. Then, finally, the assignment x = temp takes place, which assigns 10 to x, thus changing it's value back again to 10 from 12.
On the other hand, x++ = x++, first x++ takes place as described above, then LHS x++ is also evaluated. However, when it comes to assignment, it tries to assign temp to temp2 (in the language used above). However, compiler rules state that assignment to entities can be used only if they are proper lvalues, while a temporary variable IS NOT a proper lvalue (in general, one can't explicitly carry out operations ourselves on temporaries like we can do for properly defined and named variables. They exist only within the RAM for the compiler's book-keeping purposes). Hence the error: lvalue required as left operand of assignment.
Instead of that we have rectified it as int temp = x++; x = temp; (which is probably what the coder wanted to do using x++ = x++). We duly get x = 10 on printing using cout. Note that we just explicitly defined what the compiler was anyways doing internally, but doing so helped us to operate on the variable, which was otherwise not possible.

evaloder1.cpp:
Firstly, the operator << is carried out in left to right fashion. Thus, first f(p) is carried out, which does i = 1 -> 2, then subsequently 2->4 and 4->8. Then we have clash of two operators, () "function cast" and prefix increment. Prefix increment takes precedence, and ++p is carried out, wherein a temporary is generated to store the value 8 + 1 = 9, and p also itself becomes 9. This temporary is then passed into the function, and the result is p = p + temp, leading to 9 + 9 = 18, as seen in the program.
Suppose wanted to only increase p (= 9 after the increment) by it's original value (= 8), to yield 17, and not 18. Then just change the prefix increment to postfix increment. Then the temporary only stores the old value, to yield desired results.

trythis1.cpp:
This is a very interesting program. First, we have the "function cast operator" () and the postfix increment operator. Since the postfix increment operator has higher precedence, within the function call, first i++ is evaluated. As mentioned above, a temporary is created which storees the value 10, while the value of x itself increases to 11. Thus the first argument of the function, which is x, gets printed as 11, while the second argument, which is the temporary, gets printed as 10. Then again, in the next line, we have f(++i,i++). Again, by precedence, the SECOND ARGUMENT GETS EVALUATED FIRST (BUT IS PRINTED IN THE CORRECT ORDER ONLY. This is because the function first copies ALL the variables into it's local variables in it's activation frame, and only then takes some action upon them. The order of copying is decided by precedence rules, if some variables are actually expressions as in this case), and the temp stores 11, even as x is incremented to 12, while in the first expression both the temporary and x store 13, and thus the result 13 11.
Our hypothesis about the copying into activation frames is confirmed when we define a function g, which carries out the same action such as f, only that it's arguments are passed by reference. The compiler immediately raises the error: cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’, which indeed confirms that the compiler was instructed, by us to copy (or bind) the temporary generated by the prefix and postfix operators, and as pointed out above, we can NOT carry out any operation on the temporary ourselves, thus the error.

trythis2.cpp:
This is a very interesting program, which demonstrates (further extending our hypothesis in the previous paragraph), that not only does the compiler create temporaries in the activation frame (and not evaluate them necessarily in the order in which they were passed), but the values of those temporaries are updated even when expressions other than their owns are evaluated, ie:- the temporaries are updated continuously throughout the process of creation of all of them. Note that in the first line,
i:   Evaluated last. It's value is obviously 12.
i++: Evaluated first (due to precedence). temp1 created, set to 10 and i is incremented to 11.
++i: Evaluated second. temp2 created, set to 12 and i is incremented to 12. Control returns to the second argument, and temp1 is increased to 11, since i increased.
Hence the result 12 11 12. 
In the second function call:
++i: Evaluated second. temp2 created and set to 14, and i is also 14. Control goes to second argument, and temp1 is increased to 13, since i increased.
i++: Evaluated first. temp1 created and set to 12, i increases to 13.
++i: Evaluated last. temp3 created and set to 15, and i is also 15. Control goes to first argument, increases temp2 to 15, and the copying process is complete.


right-to-left.cpp:
In light of the previous explanations, this is fairly straightforward. In the first 1, assignment goes from right to left, so tempc is created first, set to 3 while c becomes 4. Then tempb is created and set to 3 and b also becomes 3. Then, tempc is assigned to b. However, since both are 3, this has no visible effect. Then, tempb is assigned to a, making it 3 from 1. Hence the output 334.
The second ouput is even more obvious and merely shows what we've been explaining all along: OPERATOR OVERLOADING CAN'T CHANGE THE PRECEDENCE RULES AND THE EVALUATION ORDER OF OPERATORS. Hence, even assignment operator for the class behaves exactly as the normal one. We additionally print the values of the id and actually make the assignment operator do something. The results are for the grader to see. (First the id of 3 changes to 2 when a2 = a3 is done, then the id of 2 changes to 1 when a1 = a2 is done).

prefixpostfix.cpp:
This program highlights a very important fact about prefix and postfix operators, ie:- Since their symbol is the same, to distinguish b/w them a dummy parameter is added so as to alter it's signature. As one can see, the variable has no use within the body of the function (infact it's not even named), confirming our hypothesis. We then explore the properties of the operators by first operating them on objects, then on pointers and observing their behaviour. As we see, that even pointers "retain the memory of the variables" in the object, and we demonstrate how the value of v keeps increasing independent of it's operation on the object itself, or on it's pointer. Check out the code for further clarity.

Exceptions.cpp:
This program demonstrates a clever use of operator overloading in the OOP. Normally, to access an array, we would define an accessor function (most probably private). Here, instead, the [] operator has been overloaded to directly access the array. This is very clever as it shows the array entries yet it prevents them from being modified from outside. This access is infact safer, as it incorporates try-catch-throw into it, thus preventing incorrect index passing, as well as meaningful error messages whenever they occur (unlike assert, which would have aborted the program), yet completing the rpogram till th end and only then displaying them.
We make the following crucial change to the program: Instead of c[i] = i, we eliminate the need of indexing altogether, and thus the errors arising out of it. We add the operator<< overloaded from the function from our Collection program. This automatically takes care of inserting the elements into their right positions, thus eliminating the error of underflow access altogether. Overflow access can still occur, if too many elemnts are sought to be added, and this is handled by throwing the OutofBound(1). Even though OutofBound(0) is unnecessary in this program, we still keep it for the sake of completeness.
