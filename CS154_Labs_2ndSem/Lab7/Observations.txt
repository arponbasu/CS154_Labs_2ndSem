In this lab we demonstrate the superiority of a structured program (which uses modern programming constructs like the do-while loop, continue and proper if-branching) vis-a-vis an unstructured one (which uses a lot of go-tos). In the end, both of them achieve the same goal, but the structured program is much easier to comprehend, analyse and develop further than the unstructured one.
In my case, I have also broken down each task at hand (in the structured program) into functions (with highly descriptive names suggesting the work they do), thus modularizing the entire program and making development of individual functions possible. For example, in these programs, I deliberately used raw arrays for not wanting to use higher data structures such as queues, but if I wanted to, I could have easily replaced the body of the leftshift function with two queue member functions (first pop, and then push. The FIFO structure then ensures a left shift). On the other hand, doing that in the go-to program would involve making changes in between the control flow itself, thus possibly introducing subtle bugs.
The algorithm I implemented has been taken from the very famous book by Knuth (Link:- http://www.kcats.org/csci/464/doc/knuth/fascicles/fasc2b.pdf, Pg#22, "Algorithm C"). As one may see, the algorithm is written in a manner where it's very tempting to use go-to statements. Thus, the algorithm was first written with go-to statements (in Goto.cpp), and then it was refactored in GotoRemoved.cpp. (The algorithm actually involves generating permutations of a given set by cyclic shifts of specific blocks in it. I have printed all the permutations of {1,2,3,4} in my case. However, I've made both the programs very general, and if one wants to permute any other set, one has to just replace the array without changing any other parameters such as size. The programs automatically infers everything else from the source array. Also, since the permutations are generated by cyclic shifts, one may see that some permutations are repeated when "the cycles complete". I could have removed the repeated permutations if I wanted to, but I deliberately kept them for they illustrate, how the algorithm actually generates the permutations, and hence are of utility in comprehension of it.)
Even the refactoring followed a specific algorithm (wasn't a hit and trial process):
1. All labels which point to atmost one other label can be replaced by their bodies wherever they have been called from.
2. After doing this, some Labels get stuck in recursive calls (say 3->2->3, and 2 was replaced by it's body), remove 3 by replacing it with a while loop (or whatever loop is deemed suitable. I used a do-while loop in this case).
3. Handle branching with if at proper places.
4. Control flow of the program, which earlier just followed the actual order in which the labels were written, may become jumbled up after the labels are replaced by their bodies. Thus, insert breaks and continues wherever necessary to redirect the control flow of the program.
Following these 4 steps, I refactored the program. I was helped in this by the following references:
References:
1. http://www.kcats.org/csci/464/doc/knuth/fascicles/fasc2b.pdf, Pg#22, "Algorithm C"
2. https://stackoverflow.com/questions/37079307/untying-knuths-knots-how-to-restructure-spaghetti-code
